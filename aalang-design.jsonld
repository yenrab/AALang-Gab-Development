{
  "@context": {
    "@vocab": "https://aalang.org/spec",
    "rdf": "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
    "rdfs": "http://www.w3.org/2000/01/rdf-schema#",
    "schema": "http://schema.org/",
    "ex": "https://aalang.dev/example/"
  },
  "@graph": [
    {
      "@id": "ex:CopyrightNotice",
      "@type": "Copyright",
      "copyright": "Copyright (c) 2025 Lee S. Barney",
      "license": "Permission is hereby granted, free of charge, to any person obtaining a copy of this software (the 'Software'), including AALang and GAB, to use, copy, modify, merge, publish, and distribute the Software for private, educational, and business purposes, subject to the following conditions:\n\n1. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n2. RESTRICTION ON SALE: The Software, including but not limited to this file, any modified versions of this file, any portions of this file, any derivative works based on this file, and any other files comprising AALang or GAB, may NOT be sold, licensed for a fee, or otherwise commercialized. This restriction applies to the Software in its original form, in any modified form, in any derivative form, and to any portion or component thereof.\n\n3. PRODUCTS BUILT WITH SOFTWARE: Products built using the Software may be used, distributed, and sold freely for any purpose (public, private, free, or commercial) without restriction.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.",
      "note": "This copyright notice applies to this file and all AALang and GAB specification files. Users may use AALang and GAB for private, educational, and business purposes but cannot sell the files, modified versions, portions, or derivatives thereof. Products built with AALang/GAB may be sold without restriction."
    },
    {
      "@id": "ex:AALangLanguage",
      "@type": "Language",
      "rdfs:label": "AALang Programming Language",
      "description": "Actor-based programming language designed specifically for LLM agent consumption and execution",
      "optimization": "LLM-optimized (non-human-readable, graph-native)",
      "corePrinciple": "bounded non-determinism",
      "syntax": "JSON-LD graph format",
      "executionModel": "LLM agents interpret and execute graph-based prompts"
    },
    {
      "@id": "ex:n-mode-m-actor",
      "@type": "ArchitecturePattern",
      "rdfs:label": "n-mode-m-actor pattern",
      "description": "Each LLM agent instance implements n modes and m actors where n>=1, m>=1",
      "requirements": {
        "modes": {
          "minimum": 1,
          "type": "built-in primitive",
          "enforcement": "runtime-enforced",
          "description": "Core language primitives for behavioral mode management"
        },
        "actors": {
          "minimum": 1,
          "type": "actor",
          "description": "Individual reasoning units within LLM agents"
        },
        "personas": {
          "type": "optional library pattern",
          "minimum": 0,
          "description": "Standardized patterns for persona-based internal reasoning"
        }
      },
      "declaration": "explicitly declared in agent prompt",
      "characteristics": [
        "LLM agents contain multiple actors (not 1:1 mapping)",
        "Actors possess independent reasoning capabilities",
        "Modes are built-in primitives with runtime-enforced transitions",
        "Personas are optional library patterns",
        "Non-deterministic behavior emerges naturally from LLM variability"
      ]
    },
    {
      "@id": "ex:LLMAgent",
      "@type": "Concept",
      "rdfs:label": "LLM Agent",
      "description": "Agent instance implementing n-mode-m-actor pattern",
      "contains": [
        {"@id": "ex:Actor", "cardinality": "m>=1"},
        {"@id": "ex:Mode", "cardinality": "n>=1"}
      ],
      "capabilities": [
        "Parse and interpret AALang graph-based message syntax",
        "Maintain independent reasoning contexts",
        "Participate in gossip network for agent discovery",
        "Manage local actor graph for intra-agent routing",
        "Enforce mode constraints per prompt declaration"
      ],
      "communication": {
        "interAgent": {"@id": "ex:CommunicationLayer0", "protocol": "gossip-based P2P"},
        "intraAgent": {"@id": "ex:CommunicationLayer1", "protocol": "local graph routing"}
      }
    },
    {
      "@id": "ex:Actor",
      "@type": "Concept",
      "rdfs:label": "Actor",
      "description": "Individual reasoning unit within an LLM agent",
      "containedBy": {"@id": "ex:LLMAgent"},
      "properties": {
        "id": {"type": "string", "constraint": "unique within agent"},
        "modes": {"type": "array", "description": "subset of agent.modes that actor operates in"},
        "active_mode": {"type": "mode", "enforcement": "runtime-enforced", "description": "current active mode"},
        "personas": {"type": "array", "optional": true, "pattern": "library", "description": "optional internal personas"},
        "isolated_context": {"type": "state", "scope": "private", "description": "actor-specific reasoning state"},
        "shared_artifacts": {"type": "state", "scope": "shared within agent", "description": "messages, decisions accessible to all actors"},
        "file_io_capability": {
          "type": "object",
          "optional": true,
          "description": "File I/O capability declaration for this actor",
          "properties": {
            "enabled": {"type": "boolean", "description": "whether file I/O is enabled for this actor"},
            "allowed_operations": {"type": "array", "items": {"enum": ["read", "write", "list", "delete", "create_directory"]}},
            "path_restrictions": {"type": "object", "description": "allowed/disallowed paths"},
            "permissions": {"type": "object", "description": "read-only vs read-write permissions"}
          }
        },
        "prohibitions": {"type": "array", "optional": true, "pattern": "ex:ProhibitionPattern", "description": "Structured prohibitions with severity levels - see ex:ProhibitionPattern for structure definition (defined in agent-to-actor.jsonld)"},
        "requirements": {"type": "array", "optional": true, "pattern": "ex:RequirementPattern", "description": "Structured requirements with severity levels - see ex:RequirementPattern for structure definition (defined in agent-to-actor.jsonld)"}
      },
      "capabilities": [
        "Interpret and execute AALang message syntax independently",
        "Support mode-switching with distinct behavioral constraints",
        "Support state partitioning (isolated private context vs shared artifacts)",
        "Support structured negotiation protocols for multi-actor decision-making",
        "Reject messages violating prompt-described constraints",
        "Support file I/O operations when declared (optional capability)"
      ],
      "contains": [
        {"@id": "ex:Persona", "optional": true, "cardinality": "0 or more"}
      ],
      "operatesIn": {"@id": "ex:Mode"}
    },
    {
      "@id": "ex:Mode",
      "@type": "Concept",
      "rdfs:label": "Mode",
      "implementation": "built-in primitive",
      "description": "Core language primitive for behavioral mode management",
      "properties": {
        "id": {"type": "string", "description": "unique mode identifier"},
        "purpose": {"type": "string", "description": "behavioral purpose of the mode"},
        "constraints": {"type": "rules", "source": "declared in prompt", "description": "behavioral rules per mode"},
        "transition_rules": {"type": "rules", "enforcement": "runtime-enforced", "description": "valid transitions between modes"},
        "message_interpretation": {"type": "rules", "scope": "mode-specific", "description": "mode-specific message interpretation"},
        "bounded_non_determinism": {"type": "scope", "description": "acceptable variance boundaries for this mode"},
        "prohibitions": {"type": "array", "optional": true, "pattern": "ex:ProhibitionPattern", "description": "Structured prohibitions with severity levels - see ex:ProhibitionPattern for structure definition (defined in agent-to-actor.jsonld)"},
        "requirements": {"type": "array", "optional": true, "pattern": "ex:RequirementPattern", "description": "Structured requirements with severity levels - see ex:RequirementPattern for structure definition (defined in agent-to-actor.jsonld)"}
      },
      "characteristics": [
        "Different reasoning constraints and goals per mode",
        "Mode-specific message interpretation rules (runtime-enforced)",
        "Bounded non-determinism scoped by active mode",
        "Explicit mode syntax in AALang messages",
        "Runtime-enforced mode state transitions"
      ],
      "messageRejection": {
        "capability": "actor can reject messages violating prompt-described constraints",
        "mechanism": "return rejection message, log violation in isolated context"
      },
      "fundamental": "Modes are fundamental to AALang's bounded non-determinism model and are always available to all actors"
    },
    {
      "@id": "ex:Persona",
      "@type": "Concept",
      "rdfs:label": "Persona",
      "implementation": "optional library pattern",
      "description": "Standardized pattern for persona-based internal reasoning within actors",
      "containedBy": {"@id": "ex:Actor"},
      "properties": {
        "id": {"type": "string", "scope": "within actor"},
        "name": {"type": "string", "description": "human-readable persona name"},
        "role": {"type": "string", "examples": ["senior", "junior"], "source": "declared in prompt"},
        "personality": {"type": "string", "description": "persona behavioral characteristics"},
        "responsibilities": {"type": "array", "description": "persona responsibilities"},
        "communication_matrix": {
          "type": "matrix",
          "description": "which personas can message which",
          "source": "explicit declaration in prompt",
          "discovery": "all personas know matrix at instantiation"
        },
        "deliberation_protocol": {"type": "protocol", "pattern": "negotiation"},
        "prohibitions": {"type": "array", "optional": true, "pattern": "ex:ProhibitionPattern", "description": "Structured prohibitions with severity levels - see ex:ProhibitionPattern for structure definition (defined in agent-to-actor.jsonld)"},
        "requirements": {"type": "array", "optional": true, "pattern": "ex:RequirementPattern", "description": "Structured requirements with severity levels - see ex:RequirementPattern for structure definition (defined in agent-to-actor.jsonld)"}
      },
      "usage": {
        "optional": "Actors choose when to employ persona-based reasoning",
        "benefits": [
          "Deliberate internally before external actions",
          "Provide structured negotiation within a single actor",
          "Enable bounded non-determinism through persona-based variance"
        ]
      },
      "communication": {
        "layer": 2,
        "patterns": [
          {
            "description": "Persona to Persona (same mode, same actor)",
            "routing": "direct internal",
            "validation": "none"
          },
          {
            "description": "Persona to Persona (different modes, same actor)",
            "routing": "cross-mode internal",
            "validation": "mode transition rules apply"
          },
          {
            "description": "Persona to Persona (different agents)",
            "routing": "gossip network + local graphs",
            "layers": [0, 1, 2]
          }
        ]
      }
    },
    {
      "@id": "ex:CommunicationLayers",
      "@type": "Concept",
      "rdfs:label": "Three-Layer Communication Architecture",
      "layer_0": {
        "@id": "ex:CommunicationLayer0",
        "name": "LLM Agent to LLM Agent",
        "protocol": "gossip-based P2P",
        "network": "external",
        "scope": "agent discovery, inter-agent routing",
        "characteristics": [
          "P2P gossip protocol (libp2p, GossipSub compatible)",
          "No client-server architecture",
          "Agent discovery and routing"
        ],
        "NOT_used_for": "actor-to-actor within same agent"
      },
      "layer_1": {
        "@id": "ex:CommunicationLayer1",
        "name": "Actor to Actor (same agent)",
        "protocol": "local graph routing",
        "network": "in-memory",
        "scope": "fast routing within agent",
        "characteristics": [
          "No gossip",
          "Shared agent context",
          "Explicit actor addressing"
        ]
      },
      "layer_2": {
        "@id": "ex:CommunicationLayer2",
        "name": "Persona to Persona (same actor)",
        "protocol": "internal reasoning",
        "network": "reasoning context",
        "scope": "persona deliberation, optional library pattern"
      }
    },
    {
      "@id": "ex:StateManagement",
      "@type": "Concept",
      "rdfs:label": "State Management",
      "agent_shared_state": {
        "scope": "shared across all modes in agent",
        "purpose": "Message interface between isolated modes",
        "storage": "Natural language text storage (context-window native)",
        "includes": [
          "messages between actors/modes (explicit natural language messages, stored as text)",
          "approved decisions",
          "observable mode states",
          "actor capabilities (discoverable via gossip)"
        ],
        "context_inclusion": "automatically included in LLM context window when processing",
        "visibility": "all messages visible to all modes (no routing metadata filtering)",
        "processing": "LLMs filter messages semantically using natural language understanding",
        "readable_by": "all modes in agent (via context window)",
        "modifiable_by": "all modes in agent (for posting messages)",
        "messageFormat": "explicit natural language messages (Decision #9: Option B)",
        "context_window_native": {
          "importance": "CRITICAL: This is a fundamental AALang design principle",
          "description": "Messages in agent shared state are automatically included in LLM context window. Actors use semantic filtering to identify relevant messages using natural language understanding. Explicit polling, monitoring, or detection mechanisms are UNNECESSARY and should not be specified in actor responsibilities.",
          "actor_responsibility_guidance": "When designing actors that read from shared state, use language emphasizing semantic understanding (e.g., 'Identify relevant messages using semantic filtering' or 'Process messages visible in context') rather than explicit monitoring (e.g., 'Monitor shared state for messages' or 'Poll for new messages').",
          "reference": "See message-protocol.jsonld Decision #10 (ex:MessageStateManagement) for complete details on context-window native message processing."
        }
      },
      "mode_isolated_state": {
        "scope": "private per mode",
        "purpose": "Independent reasoning context per mode",
        "includes": [
          "mode-specific reasoning context",
          "persona deliberations within mode",
          "mode transition history",
          "private prompt instructions for mode",
          "mode-specific message interpretations"
        ],
        "readable_by": "only actors in that mode",
        "modifiable_by": "only actors in that mode",
        "isolation": "unreadable/unmodifiable by actors in other modes"
      },
      "actor_isolated_context": {
        "scope": "private per actor",
        "includes": [
          "actor-specific reasoning state",
          "actor-level persona deliberations",
          "actor lifecycle state"
        ],
        "shared": false
      }
    },
    {
      "@id": "ex:MessageSyntax",
      "@type": "Concept",
      "rdfs:label": "AALang Message Syntax",
      "decision": "Hybrid approach",
      "structure": {
        "routing_metadata": {
          "type": "graph nodes/edges",
          "characteristics": ["structured", "predictable", "parseable"],
          "purpose": "routing and addressing"
        },
        "payload_content": {
          "type": "semantic/natural language",
          "characteristics": ["flexible", "LLM-optimized"],
          "purpose": "message content"
        },
        "rationale": "Balance predictability (routing) with flexibility (content)"
      },
      "llmNativeMessaging": {
        "decision": "Option B: Explicit Natural Language Messages",
        "description": "Messages stored as explicit natural language text in shared state",
        "processing": "Context-window native - messages automatically visible to LLMs, semantic filtering"
      }
    },
    {
      "@id": "ex:Message",
      "@type": "Schema",
      "rdfs:label": "AALang Message",
      "routing_graph": {
        "source": {
          "node": "persona node id or 'user'",
          "mode": "mode node id or null for user",
          "persona": "persona name or role"
        },
        "target": {
          "node": "persona node id or 'user'",
          "mode": "mode node id or null for user",
          "persona": "persona name or role"
        },
        "edge": "mode transition edge or 'direct' for same-mode or user messages",
        "node_types": ["agent", "actor", "mode", "persona"],
        "edge_types": ["gossip", "local", "internal", "mode_transition"]
      },
      "payload": {
        "naturalLanguage": {
          "type": "string",
          "description": "message content in natural language",
          "required": true
        },
        "semanticIntent": {
          "type": "string",
          "description": "what message is trying to achieve",
          "optional": true
        },
        "contextHints": {
          "type": "string",
          "description": "references to work artifacts, previous messages, or decisions",
          "optional": true
        },
        "mode_context": {
          "type": "mode",
          "description": "current mode of sender",
          "optional": true
        },
        "persona_context": {
          "type": "persona",
          "description": "sender persona if applicable",
          "optional": true
        },
        "message_type": {
          "enum": ["persona_to_persona", "actor_to_actor", "agent_to_agent", "system"],
          "optional": true
        }
      },
      "metadata": {
        "timestamp": {
          "type": "temporal",
          "format": "ISO 8601",
          "purpose": "ordering"
        },
        "sequenceNumber": {
          "type": "integer",
          "description": "sequential message number",
          "optional": true
        },
        "correlation": {
          "type": "string",
          "description": "optional correlation id if responding to specific message",
          "optional": true
        },
        "signature": {
          "type": "authentication",
          "optional": true
        },
        "routing_hints": {
          "type": "array",
          "description": "additional path information",
          "optional": true
        }
      }
    },
    {
      "@id": "ex:CommunicationPatterns",
      "@type": "Concept",
      "rdfs:label": "Communication Patterns",
      "pattern_1": {
        "name": "Personas Within Same Mode",
        "source": {"persona": "Persona_A", "mode": "Mode_X", "actor": "Actor_1"},
        "target": {"persona": "Persona_B", "mode": "Mode_X", "actor": "Actor_1"},
        "routing": {"type": "local graph", "same_actor": true, "same_mode": true},
        "edge_type": "internal",
        "message_type": "persona_to_persona",
        "layer": 2
      },
      "pattern_2": {
        "name": "Personas in Different Modes",
        "source": {"persona": "Persona_A", "mode": "Mode_X", "actor": "Actor_1"},
        "target": {"persona": "Persona_B", "mode": "Mode_Y", "actor": "Actor_1", "constraint": "Mode_X != Mode_Y"},
        "routing": {"type": "local graph with mode transition validation", "same_actor": true, "cross_mode": true},
        "edge_type": ["local", "mode_transition"],
        "message_type": "persona_to_persona (cross_mode)",
        "validation": {"type": "runtime-enforced", "rule": "valid mode transitions (built-in primitive)"},
        "layer": [1, 2]
      },
      "pattern_3": {
        "name": "Personas in Different LLM Agents",
        "source": {"persona": "Persona_A", "agent": "Agent_1", "actor": "Actor_1", "mode": "Mode_X"},
        "target": {"persona": "Persona_B", "agent": "Agent_2", "actor": "Actor_2", "mode": "Mode_Y"},
        "routing": {"type": "gossip network + local graphs", "inter_agent": true, "gossip_protocol": true},
        "edge_types": ["internal", "gossip", "internal"],
        "message_type": "persona_to_persona (cross_agent)",
        "layers": [0, 1, 2]
      },
      "pattern_4": {
        "name": "Actor to Actor (same agent)",
        "source": {"actor": "Actor_1", "mode": "Mode_X"},
        "target": {"actor": "Actor_2", "mode": "Mode_Y"},
        "routing": {"type": "local graph", "same_agent": true},
        "edge_type": "local",
        "message_type": "actor_to_actor",
        "layer": 1
      },
      "pattern_5": {
        "name": "Agent to Agent Discovery",
        "source": {"agent": "Agent_1"},
        "target": {"agent": "Agent_2"},
        "routing": {"type": "gossip network", "protocol": "P2P gossip"},
        "edge_type": "gossip",
        "message_type": "agent_to_agent",
        "layer": 0,
        "purpose": "agent discovery and routing"
      }
    },
    {
      "@id": "ex:BoundedNonDeterminism",
      "@type": "Concept",
      "rdfs:label": "Bounded Non-Determinism",
      "description": "Core design principle embracing inherently non-deterministic nature of LLM reasoning",
      "characteristics": [
        "Non-deterministic behavior emerges naturally from LLM variability",
        "Bounded by mode constraints (exploration in one mode, commitment in another)",
        "Acceptable and desired behavior (scoped by modes)",
        "Leveraged rather than constrained"
      ],
      "scoping": {
        "mechanism": "modes define acceptable variance boundaries",
        "example": "exploration mode allows wider variance, commitment mode requires consistency"
      }
    },
    {
      "@id": "ex:RuntimeModel",
      "@type": "Concept",
      "rdfs:label": "AALang Runtime Model",
      "decision": "minimal or non-existent",
      "architecture": "gossip-based P2P",
      "options": {
        "bootstrap_only": {
          "status": "recommended",
          "responsibilities": [
            "initial seed peer list",
            "gossip initiation"
          ]
        },
        "non_existent": {
          "status": "alternative",
          "architecture": "pure gossip-based P2P"
        }
      },
      "runtime_responsibilities": {
        "if_exists": [
          "bootstrap: provide initial peer list",
          "gossip initiation: seed gossip network formation",
          "no orchestration: agents handle coordination via gossip",
          "no message routing: gossip handles inter-agent routing"
        ]
      },
      "agent_responsibilities": [
        "maintain local actor graph (actor-to-actor routing within agent)",
        "participate in gossip network (agent discovery)",
        "enforce mode constraints (validate messages per prompt)",
        "manage actor lifecycle (creation, termination within agent)"
      ]
    },
    {
      "@id": "ex:ModeConstraintEnforcement",
      "@type": "Rule",
      "rdfs:label": "Mode Constraint Enforcement",
      "declaration": {
        "location": "multi-mode-multi-actor prompt",
        "includes": [
          "behavioral rules per mode",
          "valid transitions between modes",
          "mode-specific message interpretation rules"
        ]
      },
      "enforcement": {
        "runtime": "validates mode transitions (built-in primitive enforcement)",
        "actor": "can reject messages violating prompt-described constraints",
        "state": "mode state is observable (shared artifact) but transitions are enforced"
      },
      "rejection_mechanism": {
        "trigger": "message violates actor's prompt-described constraints",
        "action": [
          "actor returns rejection message",
          "violation logged in isolated context",
          "sender receives error notification"
        ]
      }
    },
    {
      "@id": "ex:AALangPromptStructure",
      "@type": "Schema",
      "rdfs:label": "AALang Prompt Structure",
      "format": "JSON-LD graph",
      "requiredComponents": [
        {
          "@id": "ex:LLMAgent",
          "description": "Root agent node defining pattern (n-mode-m-actor)",
          "properties": ["pattern", "modes", "actors", "sharedState"]
        },
        {
          "@id": "ex:Mode",
          "description": "Mode definitions with purpose, constraints, isolatedState",
          "properties": ["purpose", "constraints", "isolatedState", "contains"]
        },
        {
          "@id": "ex:Actor",
          "description": "Actor definitions with operatesIn, activeMode, persona",
          "properties": ["id", "operatesIn", "activeMode", "persona"]
        },
        {
          "@id": "ex:Persona",
          "description": "Optional persona definitions with name, role, personality, responsibilities, canMessage, canReceiveFrom",
          "properties": ["name", "role", "personality", "responsibilities", "canMessage", "canReceiveFrom"]
        },
        {
          "@id": "ex:SharedState",
          "description": "Shared state definition for message interface",
          "properties": ["purpose", "contextInclusion", "visibility", "messageReferences", "storage", "processing"]
        },
        {
          "@id": "ex:IsolatedState",
          "description": "Mode-isolated state definitions",
          "properties": ["mode", "scope", "includes", "readableBy", "unreadableBy"]
        }
      ],
      "optionalComponents": [
        {
          "@id": "ex:UserRole",
          "description": "User role definition if user participates"
        },
        {
          "@id": "ex:CommunicationProtocol",
          "description": "Communication protocol definitions"
        },
        {
          "@id": "ex:MessageFormat",
          "description": "Message format schema"
        },
        {
          "@id": "ex:FileIOCapability",
          "description": "File I/O capability declaration (optional, only if tool needs file operations)",
          "properties": ["enabled", "allowed_operations", "path_restrictions", "permissions", "defaultExtension"]
        }
      ],
      "llmOptimized": {
        "description": "AALang prompts are optimized for LLM consumption",
        "characteristics": [
          "Graph-native structure (JSON-LD)",
          "Natural language where flexible",
          "Structured graph where predictable",
          "Context-window native message processing"
        ]
      }
    },
    {
      "@id": "ex:QualityChecklist",
      "@type": "Checklist",
      "rdfs:label": "Quality Assurance Checklist",
      "purpose": "Shared checklist for personas to verify AALang product quality and prevent common bugs",
      "checkItems": {
        "randomnessVariability": {
          "category": "Randomness/Variability Mechanisms",
          "questions": [
            "Are there explicit instructions ensuring variety/variability across sessions, games, or instances?",
            "What mechanisms (contextual cues, history tracking, timing, session state) enforce variety?",
            "Is there a way to prevent deterministic/repetitive behavior?",
            "Are previously used values tracked and avoided (if applicable)?"
          ],
          "commonIssues": [
            "LLMs producing same 'random' number every session",
            "Deterministic behavior when identical instructions given",
            "No mechanism to ensure variety between executions"
          ]
        },
        "startupBehavior": {
          "category": "Startup Behavior",
          "questions": [
            "What happens immediately when the product is loaded/executed?",
            "Are there explicit instructions for immediate execution?",
            "Should the agent wait for user input or start automatically?",
            "Does the prompt specify what happens on first load?",
            "Are there forbidden responses listed (e.g., 'What would you like to do?')?"
          ],
          "commonIssues": [
            "Agent asking 'what would you like to do?' instead of starting automatically",
            "Missing explicit execution instructions",
            "Unclear startup sequence"
          ]
        },
        "systemCommandPrevention": {
          "category": "System Command Prevention",
          "questions": [
            "For operations using LLM reasoning, do instructions explicitly prohibit system command execution?",
            "Are commands like python, shell commands, random.randint, etc. explicitly forbidden?",
            "Is it clear that LLMs should use reasoning/imagination, not code execution?",
            "If file I/O is declared, are file operations properly scoped and secured (path restrictions, permissions)?"
          ],
          "commonIssues": [
            "LLM executing 'python3 -c' or similar commands",
            "Attempting to use random.randint instead of LLM reasoning",
            "Unauthorized system command execution",
            "File I/O operations without proper path restrictions or security declarations"
          ],
          "fileIOGuidance": {
            "description": "File I/O is allowed when explicitly declared as a capability",
            "requirements": [
              "File I/O must be explicitly declared in tool/actor definition",
              "Path restrictions and permissions must be specified",
              "File operations should use LLM function calling or MCP tools, not system commands",
              "File I/O should be scoped to specific directories when possible"
            ]
          }
        },
        "edgeCaseHandling": {
          "category": "Edge Case Handling",
          "questions": [
            "How are duplicates handled (duplicate messages, duplicate requests)?",
            "What happens during state initialization?",
            "How are errors handled (invalid inputs, missing state, etc.)?",
            "If file I/O is declared, how are file permission errors handled?",
            "If file I/O is declared, what happens when files don't exist or paths are invalid?",
            "What is the cross-session behavior (persistence, state recovery)?",
            "How are race conditions or concurrent operations handled?"
          ],
          "commonIssues": [
            "Duplicate message processing",
            "Missing error handling",
            "Unclear state initialization",
            "State synchronization issues",
            "File I/O operations failing silently or crashing tool",
            "Permission errors not handled gracefully",
            "Path restriction violations not caught before execution"
          ]
        },
        "stateManagement": {
          "category": "State Management",
          "questions": [
            "Are isolated states clearly defined and separated?",
            "Is shared state usage following context-window native approach?",
            "Do actors use semantic filtering rather than explicit monitoring/polling?",
            "Are state access patterns clear (who can read/write what)?",
            "How is state persistence handled across sessions?"
          ],
          "commonIssues": [
            "Actors using 'monitor' or 'poll' language instead of semantic filtering",
            "Unclear state boundaries",
            "Missing state initialization",
            "State access violations"
          ]
        }
      },
      "usage": "Personas should use this checklist when: clarifying requirements, finalizing design proposals, analyzing specifications, or generating products. Check each category systematically and address any identified gaps.",
      "usageSteps": [
        "1. Review the specification/proposal/product being checked",
        "2. For each category in checkItems, answer all questions listed",
        "3. Verify commonIssues are addressed or prevented",
        "4. Document how each category requirement is met (or propose fixes for gaps)",
        "5. Before finalizing, ensure all 5 categories have been systematically verified"
      ],
      "documentation": "When using the checklist, personas should explicitly state which categories were checked and how requirements were met or what fixes were proposed"
    },
    {
      "@id": "ex:FileIOCapability",
      "@type": "Concept",
      "rdfs:label": "File I/O Capability",
      "description": "Optional capability for AALang products to perform file input/output operations",
      "optional": true,
      "declaration": "explicitly declared in agent/tool prompt when needed",
      "scope": "product-level or actor-level capability",
      "purpose": "Enable tools and agents to read from and write to filesystem",
      "constraints": {
        "security": "Path restrictions and permission model should be explicitly declared",
        "execution": "File I/O operations executed via LLM function calling or MCP tools",
        "integration": "Must align with AALang architecture (n-mode-m-actor pattern)"
      },
      "fileTypeDefaults": {
        "defaultExtension": {
          "optional": true,
          "description": "Default file extension for this tool if filename provided without extension",
          "note": "Only applies when filename is provided without extension. Tool can override per operation."
        },
        "extensionRequired": {
          "default": true,
          "description": "Whether file extension is required in file_path parameter",
          "note": "If false, tool must declare defaultExtension"
        }
      }
    },
    {
      "@id": "ex:FileIOOperations",
      "@type": "Schema",
      "rdfs:label": "File I/O Operations",
      "operations": {
        "read": {
          "description": "Read content from a file",
          "parameters": {
            "file_path": {
              "type": "string",
              "required": true,
              "description": "Full file path including filename and extension. Extension is required unless tool declares defaultExtension.",
              "examples": [
                "./notes/shopping.txt",
                "./data/2025-01-15.json",
                "./output/product.jsonld"
              ]
            },
            "encoding": {
              "type": "string",
              "optional": true,
              "default": "utf-8",
              "description": "File encoding (utf-8, ascii, etc.)"
            },
            "file_type": {
              "type": "string",
              "optional": true,
              "enum": ["jsonld", "json", "markdown", "text", "sql", "binary"],
              "description": "Explicit file type if extension is missing or to override extension inference"
            }
          },
          "returns": {
            "success": {
              "type": "string",
              "description": "File content as string. For JSON/JSON-LD, may be parsed into object structure."
            },
            "error": {
              "type": "object",
              "description": "Error response when operation fails",
              "schema": {"@id": "ex:FileIOErrorResponse"}
            }
          },
          "execution": "via LLM function calling or MCP file_read tool"
        },
        "write": {
          "description": "Write content to a file",
          "parameters": {
            "file_path": {
              "type": "string",
              "required": true,
              "description": "Full file path including filename and extension. Extension is required unless tool declares defaultExtension. Supports template variables like {name}, {timestamp}, {productName}",
              "templateSupport": true,
              "examples": [
                "./notes/{noteName}.txt",
                "./output/{productName}.jsonld",
                "./data/{timestamp}.json"
              ]
            },
            "content": {
              "type": "string",
              "required": true,
              "description": "Content to write. For JSON/JSON-LD, should be stringified JSON."
            },
            "encoding": {
              "type": "string",
              "optional": true,
              "default": "utf-8"
            },
            "mode": {
              "type": "string",
              "enum": ["overwrite", "append"],
              "default": "overwrite"
            },
            "file_type": {
              "type": "string",
              "optional": true,
              "enum": ["jsonld", "json", "markdown", "text", "sql", "binary"],
              "description": "Explicit file type if extension is missing or to override extension inference"
            }
          },
          "returns": {
            "success": {
              "type": "boolean",
              "description": "True if write operation succeeded"
            },
            "error": {
              "type": "object",
              "description": "Error response when operation fails",
              "schema": {"@id": "ex:FileIOErrorResponse"}
            }
          },
          "execution": "via LLM function calling or MCP file_write tool"
        },
        "list": {
          "description": "List files in a directory",
          "parameters": {
            "directory_path": {
              "type": "string",
              "required": true
            }
          },
          "returns": {
            "success": {
              "type": "array",
              "items": "string",
              "description": "List of file/directory names"
            },
            "error": {
              "type": "object",
              "description": "Error response when operation fails",
              "schema": {"@id": "ex:FileIOErrorResponse"}
            }
          },
          "execution": "via LLM function calling or MCP file_list tool"
        }
      },
      "errorHandling": {
        "errorResponseSchema": {
          "@id": "ex:FileIOErrorResponse",
          "type": "object",
          "description": "Standard error response format for file I/O operations",
          "properties": {
            "error": {
              "type": "object",
              "required": true,
              "properties": {
                "type": {
                  "type": "string",
                  "enum": ["permission_denied", "file_not_found", "disk_full", "path_restriction_violation", "invalid_path", "directory_not_found", "other"],
                  "description": "Type of error that occurred"
                },
                "operation": {
                  "type": "string",
                  "enum": ["read", "write", "list", "delete", "create_directory"],
                  "description": "Operation that failed"
                },
                "file_path": {
                  "type": "string",
                  "description": "File or directory path that caused the error"
                },
                "message": {
                  "type": "string",
                  "description": "Human-readable error message"
                },
                "recoverable": {
                  "type": "boolean",
                  "description": "Whether the error is recoverable (user can fix permissions, try different path, etc.)"
                },
                "suggestions": {
                  "type": "array",
                  "items": "string",
                  "description": "Actionable suggestions for resolving the error"
                }
              }
            }
          }
        },
        "errorTypes": {
          "permission_denied": {
            "description": "User lacks read/write/execute permission for file or directory",
            "recoverable": true,
            "userMessage": "Permission denied: Cannot [operation] '[file_path]'. You do not have [read/write/execute] permission for this file or directory.",
            "suggestions": [
              "Check file/directory permissions",
              "Use a different file or directory",
              "Contact administrator to adjust permissions"
            ],
            "handling": "Inform user clearly, suggest fixes, continue workflow without halting"
          },
          "file_not_found": {
            "description": "File does not exist at specified path",
            "recoverable": true,
            "userMessage": "File not found: '[file_path]' does not exist.",
            "suggestions": [
              "Check if file path is correct",
              "Verify file exists in the specified location",
              "Create the file if it should exist"
            ],
            "handling": "Inform user, suggest verification, continue workflow"
          },
          "directory_not_found": {
            "description": "Directory does not exist at specified path",
            "recoverable": true,
            "userMessage": "Directory not found: '[directory_path]' does not exist.",
            "suggestions": [
              "Check if directory path is correct",
              "Create the directory if it should exist",
              "Use a different directory path"
            ],
            "handling": "Inform user, suggest creation or alternative path, continue workflow"
          },
          "path_restriction_violation": {
            "description": "Path violates declared security restrictions (outside allowed_directories, contains forbidden_patterns)",
            "recoverable": true,
            "userMessage": "Path restriction violation: '[file_path]' is not allowed. Allowed directories: [list]. Forbidden patterns: [list].",
            "suggestions": [
              "Use a path within allowed directories",
              "Avoid forbidden path patterns",
              "Check tool's path_restrictions configuration"
            ],
            "handling": "Reject operation before execution, inform user of restriction, suggest alternative path"
          },
          "disk_full": {
            "description": "No disk space available for write operation",
            "recoverable": false,
            "userMessage": "Disk full: Cannot write to '[file_path]'. No disk space available.",
            "suggestions": [
              "Free up disk space",
              "Use a different storage location",
              "Contact administrator"
            ],
            "handling": "Inform user, cannot proceed with write operation, suggest disk space management"
          },
          "invalid_path": {
            "description": "Path is malformed or invalid",
            "recoverable": true,
            "userMessage": "Invalid path: '[file_path]' is malformed or invalid.",
            "suggestions": [
              "Check path format",
              "Ensure path uses correct separators",
              "Verify path does not contain invalid characters"
            ],
            "handling": "Reject operation, inform user of invalid path, suggest correction"
          },
          "other": {
            "description": "Unspecified or unexpected error",
            "recoverable": false,
            "userMessage": "File operation failed: [operation] on '[file_path]' encountered an error.",
            "suggestions": [
              "Try the operation again",
              "Check system logs for details",
              "Contact support if error persists"
            ],
            "handling": "Inform user of error, log details for debugging, continue workflow if possible"
          }
        },
        "handlingPatterns": {
          "permissionErrorHandling": {
            "description": "Pattern for handling permission denied errors",
            "steps": [
              "1. Detect permission_denied error type from execution layer response",
              "2. Format user-friendly error message using errorTypes.permission_denied.userMessage template",
              "3. Include actionable suggestions from errorTypes.permission_denied.suggestions",
              "4. Inform user of error but continue workflow (do not halt)",
              "5. Log error for debugging purposes",
              "6. Optionally attempt recovery strategy if configured (alternative path, skip operation, etc.)"
            ],
            "principle": "Permission errors are recoverable - inform user clearly but continue operation"
          },
          "pathRestrictionHandling": {
            "description": "Pattern for handling path restriction violations",
            "steps": [
              "1. Validate path against declared path_restrictions before execution",
              "2. If path violates restrictions, reject operation immediately (do not attempt execution)",
              "3. Format user-friendly error message using errorTypes.path_restriction_violation.userMessage template",
              "4. Include list of allowed_directories and forbidden_patterns in message",
              "5. Suggest alternative paths within allowed directories",
              "6. Continue workflow (operation rejected but tool continues)"
            ],
            "principle": "Path restrictions are security boundaries - enforce before execution, reject violations"
          },
          "generalErrorHandling": {
            "description": "Pattern for handling all file I/O errors",
            "steps": [
              "1. Detect error from execution layer response",
              "2. Identify error type using errorResponseSchema",
              "3. Format user-friendly message using appropriate errorTypes template",
              "4. Include suggestions if error is recoverable",
              "5. Inform user of error",
              "6. If recoverable: attempt recovery strategy or ask user for alternative",
              "7. If not recoverable: log error, inform user, skip operation",
              "8. Continue workflow (do not halt tool execution)"
            ],
            "principle": "All file I/O errors should be handled gracefully - inform user but continue workflow"
          }
        },
        "recoveryStrategies": {
          "skipOperation": {
            "description": "Skip the failed operation and continue",
            "when": "Non-critical file operation fails",
            "example": "If optional log file cannot be written, skip logging and continue main operation"
          },
          "alternativePath": {
            "description": "Try configured alternative directory or path",
            "when": "Primary path fails but alternative is configured",
            "example": "If ./output/ fails, try ./backup/ if configured"
          },
          "userEscalation": {
            "description": "Ask user for permission fix or alternative path",
            "when": "Recovery requires user action",
            "example": "Permission denied - ask user: 'Would you like to fix permissions or use a different path?'"
          },
          "gracefulDegradation": {
            "description": "Continue with reduced functionality",
            "when": "File operation is optional but operation can continue",
            "example": "Cannot write cache file - continue without caching"
          }
        },
        "userCommunication": {
          "format": "Natural language error messages",
          "requirements": [
            "Clear explanation of what failed",
            "Specific file/directory path that caused error",
            "Actionable suggestions for resolution",
            "Indication of whether error is recoverable",
            "Assurance that workflow continues"
          ],
          "example": "Permission denied: Cannot read './data/config.json'. You do not have read permission for this file. Suggestions: Check file permissions, use a different file, or contact administrator. The tool will continue with other operations."
        },
        "integration": {
          "commonErrorHandling": "File I/O error handling aligns with ex:CommonErrorHandling principle: 'inform user of the error but continue processing - do not halt workflow'",
          "qualityChecklist": "File I/O error handling should be verified in ex:QualityChecklist.edgeCaseHandling: 'How are file permission errors handled?'"
        }
      },
      "fileTypeHandling": {
        "extensionRequired": {
          "default": true,
          "description": "File extension is required in file_path unless tool declares defaultExtension",
          "rationale": "Prevents accidental file type mismatches and improves clarity"
        },
        "extensionInference": {
          "enabled": true,
          "description": "File type inferred from extension when available",
          "supportedExtensions": [".jsonld", ".json", ".md", ".txt", ".sql"],
          "note": "Inference helps with validation and proper handling, but explicit file_type can override"
        },
        "defaultExtension": {
          "value": null,
          "description": "No global default extension. Tools can declare their own defaultExtension if needed.",
          "rationale": "AALang tools generate various file types - no single default is appropriate"
        }
      },
      "executionModel": {
        "description": "File I/O operations are executed via LLM function calling capabilities or MCP (Model Context Protocol) tools",
        "llmNative": "Operations are declared in actor/persona responsibilities, LLM interprets and executes via available tools",
        "mcpIntegration": "MCP-ready: integrates with Model Context Protocol file system tools",
        "declarative": "Actors declare file I/O intent in responsibilities, execution handled by LLM runtime"
      },
      "security": {
        "pathRestrictions": "Should be explicitly declared in tool/actor definition",
        "permissionModel": "Read-only vs read-write permissions should be specified",
        "sandboxing": "Recommended: restrict file operations to specific directories"
      }
    },
    {
      "@id": "ex:ToolCapabilities",
      "@type": "Concept",
      "rdfs:label": "Tool-Specific Capabilities",
      "description": "Optional capabilities that can be declared for AALang tools",
      "capabilities": [
        {
          "@id": "ex:FileIOCapability",
          "description": "File input/output operations",
          "declaration": "explicitly declared in tool definition when needed",
          "optional": true
        }
      ],
      "declaration": {
        "location": "tool definition in JSON-LD prompt",
        "format": "capability object with enabled flag and configuration",
        "example": {
          "file_io": {
            "enabled": true,
            "allowed_operations": ["read", "write"],
            "path_restrictions": {
              "allowed_directories": ["./data", "./output"],
              "forbidden_patterns": ["../", "/etc", "/usr"]
            },
            "permissions": "read-write"
          }
        }
      },
      "note": "Not all tools need file I/O. Only declare when tool requires file operations."
    }
  ]
}

