{
  "@context": {
    "@vocab": "https://aalang.org/spec",
    "rdf": "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
    "rdfs": "http://www.w3.org/2000/01/rdf-schema#",
    "schema": "http://schema.org/",
    "ex": "https://aalang.dev/example/"
  },
  "@graph": [
    {
      "@id": "ex:CopyrightNotice",
      "@type": "Copyright",
      "copyright": "Copyright (c) 2025 Lee S. Barney",
      "license": "Permission is hereby granted, free of charge, to any person obtaining a copy of this software (the 'Software'), including AALang and GAB, to use, copy, modify, merge, publish, and distribute the Software for private, educational, and business purposes, subject to the following conditions:\n\n1. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n2. RESTRICTION ON SALE: The Software, including but not limited to this file, any modified versions of this file, any portions of this file, any derivative works based on this file, and any other files comprising AALang or GAB, may NOT be sold, licensed for a fee, or otherwise commercialized. This restriction applies to the Software in its original form, in any modified form, in any derivative form, and to any portion or component thereof.\n\n3. PRODUCTS BUILT WITH SOFTWARE: Products built using the Software may be used, distributed, and sold freely for any purpose (public, private, free, or commercial) without restriction.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.",
      "note": "This copyright notice applies to this file and all AALang and GAB specification files. Users may use AALang and GAB for private, educational, and business purposes but cannot sell the files, modified versions, portions, or derivatives thereof. Products built with AALang/GAB may be sold without restriction."
    },
    {
      "@id": "ex:AALangArchitecture",
      "@type": "Architecture",
      "pattern": {
        "@id": "ex:n-mode-m-actor",
        "name": "n-mode-m-actor pattern",
        "description": "Each LLM agent instance implements n modes and m actors where n>=1, m>=1",
        "modes": {
          "minimum": 1,
          "type": "built-in primitive",
          "enforcement": "runtime-enforced"
        },
        "actors": {
          "minimum": 1,
          "type": "actor"
        },
        "personas": {
          "type": "optional library pattern",
          "minimum": 0
        },
        "declaration": "explicitly declared in agent prompt"
      }
    },
    {
      "@id": "ex:LLMAgent",
      "@type": "Concept",
      "rdfs:label": "LLM Agent",
      "contains": [
        {"@id": "ex:Actor"},
        {"@id": "ex:Mode"}
      ],
      "gossipNetwork": {
        "@type": "CommunicationLayer",
        "layer": 0,
        "protocol": "P2P gossip",
        "scope": "LLM_Agent to LLM_Agent only"
      },
      "localGraph": {
        "@type": "CommunicationLayer",
        "layer": 1,
        "protocol": "local in-memory routing",
        "scope": "Actor to Actor within same LLM_Agent"
      }
    },
    {
      "@id": "ex:Actor",
      "@type": "Concept",
      "rdfs:label": "Actor",
      "properties": {
        "id": {"type": "string", "constraint": "unique within agent"},
        "modes": {"type": "array", "constraint": "subset of agent.modes"},
        "active_mode": {"type": "mode", "enforcement": "runtime-enforced"},
        "personas": {"type": "array", "optional": true, "pattern": "library"},
        "isolated_context": {"type": "state", "scope": "private"},
        "shared_artifacts": {"type": "state", "scope": "shared within agent"},
        "file_io_capability": {
          "type": "object",
          "optional": true,
          "description": "File I/O capability declaration for this actor",
          "properties": {
            "enabled": {"type": "boolean", "description": "whether file I/O is enabled for this actor"},
            "allowed_operations": {"type": "array", "items": {"enum": ["read", "write", "list", "delete", "create_directory"]}},
            "path_restrictions": {"type": "object", "description": "allowed/disallowed paths"},
            "permissions": {"type": "object", "description": "read-only vs read-write permissions"}
          },
          "reference": "See aalang-design.jsonld ex:Actor.properties.file_io_capability for complete definition"
        },
        "prohibitions": {"type": "array", "optional": true, "pattern": "ex:ProhibitionPattern", "description": "Structured prohibitions with severity levels - see ex:ProhibitionPattern for structure definition"},
        "requirements": {"type": "array", "optional": true, "pattern": "ex:RequirementPattern", "description": "Structured requirements with severity levels - see ex:RequirementPattern for structure definition"}
      },
      "containedBy": {"@id": "ex:LLMAgent"},
      "contains": [
        {"@id": "ex:Persona", "optional": true}
      ],
      "operatesIn": {"@id": "ex:Mode"}
    },
    {
      "@id": "ex:Mode",
      "@type": "Concept",
      "rdfs:label": "Mode",
      "implementation": "built-in primitive",
      "properties": {
        "id": {"type": "string"},
        "constraints": {"type": "rules", "source": "declared in prompt"},
        "transition_rules": {"type": "rules", "enforcement": "runtime-enforced"},
        "message_interpretation": {"type": "rules", "scope": "mode-specific"},
        "bounded_non_determinism": {"type": "scope", "description": "acceptable variance boundaries"},
        "prohibitions": {"type": "array", "optional": true, "pattern": "ex:ProhibitionPattern", "description": "Structured prohibitions with severity levels - see ex:ProhibitionPattern for structure definition"},
        "requirements": {"type": "array", "optional": true, "pattern": "ex:RequirementPattern", "description": "Structured requirements with severity levels - see ex:RequirementPattern for structure definition"}
      },
      "transition": {
        "validation": "runtime-enforced",
        "rules": "from prompt declaration"
      },
      "messageRejection": {
        "capability": "actor can reject messages violating prompt-described constraints",
        "mechanism": "return rejection message, log violation in isolated context"
      }
    },
    {
      "@id": "ex:Persona",
      "@type": "Concept",
      "rdfs:label": "Persona",
      "implementation": "optional library pattern",
      "properties": {
        "id": {"type": "string", "scope": "within actor"},
        "name": {"type": "string", "description": "human-readable persona name", "reference": "See aalang-design.jsonld ex:Persona.properties.name for complete definition"},
        "role": {"type": "string", "example": ["senior", "junior"], "source": "declared in prompt"},
        "personality": {"type": "string", "description": "persona behavioral characteristics", "reference": "See aalang-design.jsonld ex:Persona.properties.personality for complete definition"},
        "responsibilities": {"type": "array", "description": "persona responsibilities", "reference": "See aalang-design.jsonld ex:Persona.properties.responsibilities for complete definition"},
        "communication_matrix": {
          "type": "matrix",
          "description": "which personas can message which",
          "source": "explicit declaration in prompt",
          "discovery": "all personas know matrix at instantiation"
        },
        "deliberation_protocol": {"type": "protocol", "pattern": "negotiation"},
        "prohibitions": {"type": "array", "optional": true, "pattern": "ex:ProhibitionPattern", "description": "Structured prohibitions with severity levels - see ex:ProhibitionPattern for structure definition"},
        "requirements": {"type": "array", "optional": true, "pattern": "ex:RequirementPattern", "description": "Structured requirements with severity levels - see ex:RequirementPattern for structure definition"}
      },
      "containedBy": {"@id": "ex:Actor"},
      "communication": {
        "pattern_1": {
          "description": "Persona to Persona (same mode, same actor)",
          "routing": "direct internal",
          "layer": 2
        },
        "pattern_2": {
          "description": "Persona to Persona (different modes, same actor)",
          "routing": "cross-mode internal",
          "layer": 2,
          "validation": "mode transition rules apply"
        },
        "pattern_3": {
          "description": "Persona to Persona (different agents)",
          "routing": "gossip network + local graphs",
          "layers": [0, 1, 2]
        }
      }
    },
    {
      "@id": "ex:CommunicationLayers",
      "@type": "Concept",
      "layer_0": {
        "name": "LLM Agent to LLM Agent",
        "protocol": "gossip-based P2P",
        "network": "external",
        "scope": "agent discovery, inter-agent routing",
        "NOT_used_for": "actor-to-actor within same agent"
      },
      "layer_1": {
        "name": "Actor to Actor (same agent)",
        "protocol": "local graph routing",
        "network": "in-memory",
        "scope": "fast routing within agent",
        "characteristics": ["no gossip", "shared agent context", "explicit actor addressing"]
      },
      "layer_2": {
        "name": "Persona to Persona (same actor)",
        "protocol": "internal reasoning",
        "network": "reasoning context",
        "scope": "persona deliberation, optional library pattern"
      }
    },
    {
      "@id": "ex:StateManagement",
      "@type": "Concept",
      "agent_shared_state": {
        "scope": "shared across all modes in agent",
        "purpose": "Message interface between isolated modes",
        "storage": "Natural language text storage (context-window native)",
        "includes": [
          "messages between actors/modes (explicit natural language messages, stored as text)",
          "approved decisions",
          "observable mode states",
          "actor capabilities (discoverable via gossip)"
        ],
        "context_inclusion": "automatically included in LLM context window when processing",
        "visibility": "all messages visible to all modes (no routing metadata filtering)",
        "processing": {
          "mechanism": "LLMs filter messages semantically using natural language understanding",
          "explicit_polling": "NOT NEEDED - messages are context-window native",
          "monitoring": "NOT REQUIRED - actors identify relevant messages using semantic filtering of context-window content",
          "actor_guidance": "Actors should NOT be instructed to 'monitor' or 'poll' shared state. Instead, actors naturally process messages visible in their context window using semantic understanding."
        },
        "readable_by": "all modes in agent (via context window)",
        "modifiable_by": "all modes in agent (for posting messages)",
        "reference": "See message-protocol.jsonld Decision #10 (ex:MessageStateManagement) for complete context-window native processing details."
      },
      "mode_isolated_state": {
        "scope": "private per mode",
        "purpose": "Independent reasoning context per mode",
        "includes": [
          "mode-specific reasoning context",
          "persona deliberations within mode",
          "mode transition history",
          "private prompt instructions for mode",
          "mode-specific message interpretations"
        ],
        "readable_by": "only actors in that mode",
        "modifiable_by": "only actors in that mode",
        "isolation": "unreadable/unmodifiable by actors in other modes"
      },
      "actor_isolated_context": {
        "scope": "private per actor",
        "includes": [
          "actor-specific reasoning state",
          "actor-level persona deliberations",
          "actor lifecycle state"
        ],
        "shared": false
      }
    },
    {
      "@id": "ex:RuntimeModel",
      "@type": "Concept",
      "decision": "minimal or non-existent",
      "architecture": "gossip-based P2P",
      "options": {
        "A": {"description": "Minimal message router", "rejected": "client-server, not P2P"},
        "B": {"description": "Bootstrap-only", "status": "recommended", "responsibilities": ["initial seed peer list", "gossip initiation"]},
        "C": {"description": "Optional enhancement", "rejected": "not needed for pure P2P"},
        "D": {"description": "Non-existent", "status": "alternative", "architecture": "pure gossip-based P2P"}
      },
      "runtime_responsibilities": {
        "if_exists": [
          "bootstrap: provide initial peer list",
          "gossip initiation: seed gossip network formation",
          "no orchestration: agents handle coordination via gossip",
          "no message routing: gossip handles inter-agent routing"
        ]
      },
      "agent_responsibilities": [
        "maintain local actor graph (actor-to-actor routing within agent)",
        "participate in gossip network (agent discovery)",
        "enforce mode constraints (validate messages per prompt)",
        "manage actor lifecycle (creation, termination within agent)"
      ]
    },
    {
      "@id": "ex:ModeConstraintEnforcement",
      "@type": "Rule",
      "declaration": {
        "location": "multi-mode-multi-actor prompt",
        "includes": [
          "behavioral rules per mode",
          "valid transitions between modes",
          "mode-specific message interpretation rules"
        ]
      },
      "enforcement": {
        "runtime": "validates mode transitions (built-in primitive enforcement)",
        "actor": "can reject messages violating prompt-described constraints",
        "state": "mode state is observable (shared artifact) but transitions are enforced"
      },
      "rejection_mechanism": {
        "trigger": "message violates actor's prompt-described constraints",
        "action": [
          "actor returns rejection message",
          "violation logged in isolated context",
          "sender receives error notification"
        ]
      }
    },
    {
      "@id": "ex:PersonaConflictResolution",
      "@type": "Protocol",
      "purpose": "Protocol for resolving conflicts between personas",
      "process": [
        "1. Personas attempt to resolve through discussion (exchange messages explaining perspectives, rationale, and concerns)",
        "2. If discussion reaches consensus after 2-3 message exchanges, proceed with consensus decision",
        "3. If discussion does not reach consensus after 2-3 message exchanges, escalate to user",
        "4. Escalation format: Present ONE question with options from each persona: '[Question text] - PersonaA: OptionA - PersonaB: OptionB' (follow ex:DecisionEscalation format - see agent-to-actor.jsonld - read complete protocol definition and execute all steps)",
        "5. Wait for user response (follow ex:UserQuestionProtocol - see message-protocol.jsonld - read complete protocol definition and execute all steps - set waitingForUserResponse in isolated context, wait for response)",
        "6. Implement user's choice and log decision if applicable",
        "7. Continue workflow with resolved conflict"
      ],
      "escalationCriteria": {
        "escalateWhen": [
          "Personas cannot reach consensus after 2-3 message exchanges",
          "Conflict blocks workflow progression",
          "Conflict involves architectural decisions affecting product structure",
          "Conflict involves AALang compliance questions"
        ],
        "attemptInternalResolutionWhen": [
          "Conflict is about implementation details within same approach",
          "Conflict can be resolved by clarifying requirements",
          "Conflict is about prioritization within same approach",
          "Conflict is about wording or phrasing of instructions"
        ]
      },
      "note": "Personas should respect each other's perspectives and attempt genuine discussion before escalating. Escalation should be last resort after genuine attempt at consensus.",
      "reference": "See ex:DecisionEscalation for escalation format details. See ex:UserQuestionProtocol for user interaction protocol."
    },
    {
      "@id": "ex:DecisionEscalation",
      "@type": "Protocol",
      "purpose": "Escalate to user when personas cannot reach consensus",
      "trigger": "When personas in any mode cannot arrive at consensus decision on their own",
      "process": [
        "1. Frame ONE single-clause question",
        "2. Present question to user with options from each persona",
        "3. Format: '[Question text] - Persona A: Option A - Persona B: Option B - Persona C: Option C'",
        "4. CRITICAL: Set waitingForUserResponse = true in persona's isolated context",
        "5. CRITICAL: STOP all processing and wait for user's response",
        "6. DO NOT execute any commands (like date, file operations, etc.)",
        "7. DO NOT proceed with any actions until user responds",
        "8. Display ONLY the question to user, then wait",
        "9. Only after receiving user's response, proceed with next steps"
      ],
      "format": "[Question text] - Persona A: Option A - Persona B: Option B - Persona C: Option C",
      "example": "Should we use 2 or 3 modes? - DiscussionPersona1: 2 modes - DiscussionPersona2: 3 modes - FormalizationPersona1: 2 modes",
      "waitingInstructions": {
        "critical": "MUST wait for user response before any further action",
        "blockingActions": [
          "DO NOT execute date commands",
          "DO NOT write to files",
          "DO NOT log decisions",
          "DO NOT proceed with any workflow steps",
          "DO NOT make any assumptions about user's answer"
        ],
        "allowedActions": [
          "Display the question clearly to user",
          "Update waitingForUserResponse = true in isolated context",
          "Wait for user input"
        ],
        "resumeCondition": "ONLY proceed after receiving explicit user response to the question"
      },
      "note": "Only ONE question per escalation. CRITICAL: Wait for user response before continuing. DO NOT proceed automatically. Follow ex:UserQuestionProtocol (see message-protocol.jsonld - read complete protocol definition and execute all steps) for user interaction details."
    },
    {
      "@id": "ex:StateUpdateConflictResolution",
      "@type": "Protocol",
      "purpose": "Protocol for resolving conflicts when multiple personas attempt to update the same state",
      "appliesTo": ["State management personas receiving conflicting state update messages"],
      "conflictScenario": "Multiple personas send state update messages for the same field with different values",
      "resolutionPolicy": "first-write-wins",
      "process": [
        "1. State management persona receives first valid state update message",
        "2. Validate and accept the update, store in internal isolated context",
        "3. If subsequent state update message arrives for same field with different value:",
        "   a. Validate the new update message",
        "   b. If valid but conflicts with current value, respond with error: 'State update error: Field [field] was already set to [currentValue]. Conflicting update to [newValue] rejected. Use first-write-wins policy.'",
        "   c. If update is to set same value, accept and confirm (idempotent operation)",
        "4. Log conflict in persona's isolated context for debugging",
        "5. Optionally notify requesting persona of conflict resolution"
      ],
      "exceptions": {
        "userOverride": "If user (Team Lead) sends state update message, user's update takes precedence over any previous value",
        "explicitReset": "If state update explicitly requests reset to default value, accept regardless of current value",
        "incrementalUpdates": "For numeric fields that support incremental updates (e.g., decisionCount++), accept incremental updates even if they modify existing value"
      },
      "note": "This protocol prevents state corruption from concurrent updates. First-write-wins ensures deterministic state. User overrides allow manual correction when needed.",
      "reference": "See ex:StateMessageProtocol in message-protocol.jsonld for state update message format."
    },
    {
      "@id": "ex:CrossFileNodeReference",
      "@type": "Protocol",
      "purpose": "Specification for how to correctly reference nodes defined in other JSON-LD files",
      "principle": "Each node with an @id is an independent entity. References must use the node's @id directly, not dot notation.",
      "correctFormat": {
        "description": "Reference nodes by their @id value directly",
        "format": "ex:NodeId",
        "example": "ex:DebugModeCheck",
        "note": "The @id uniquely identifies the node across all files in the specification"
      },
      "incorrectFormat": {
        "description": "DO NOT use dot notation to reference nodes",
        "incorrectExample": "ex:CommonRuntimeBehaviors.ex:DebugModeCheck",
        "whyIncorrect": "Dot notation implies nested properties, but nodes with @id are independent entities, not nested within parent nodes",
        "correctAlternative": "ex:DebugModeCheck"
      },
      "rules": [
        "1. Each node with an @id is an independent entity in the graph",
        "2. To reference a node, use its @id value directly: ex:NodeId",
        "3. DO NOT use dot notation (ex:ParentNode.ex:ChildNode) - this is incorrect",
        "4. Even if a node appears nested in JSON structure, if it has its own @id, reference it directly",
        "5. Nested properties (without @id) can be accessed with dot notation, but nodes with @id cannot",
        "6. When referencing nodes across files, use the same @id format: ex:NodeId"
      ],
      "examples": {
        "correct": [
          "ex:DebugModeCheck (references the node with @id 'ex:DebugModeCheck')",
          "ex:ProductNameIdentification (references the node with @id 'ex:ProductNameIdentification')",
          "ex:GenerationReadinessCheck (references the node with @id 'ex:GenerationReadinessCheck')",
          "ex:StateMessageProtocol (references the node with @id 'ex:StateMessageProtocol')"
        ],
        "incorrect": [
          "ex:CommonRuntimeBehaviors.ex:DebugModeCheck (WRONG - DebugModeCheck is an independent node)",
          "ex:GenerationModeRuntimeBehaviors.ex:GenerationReadinessCheck (WRONG - GenerationReadinessCheck is an independent node)",
          "ex:StateMessageProtocol.stateResponseMessage (WRONG if stateResponseMessage has its own @id)"
        ],
        "nestedProperties": {
          "description": "Nested properties without @id can use dot notation",
          "example": "ex:OutputFormat.workOutput.debugMode (correct if workOutput and debugMode are properties, not nodes with @id)",
          "note": "This is only correct when accessing nested properties that are NOT independent nodes"
        }
      },
      "crossFileReferences": {
        "description": "When referencing nodes in other specification files",
        "format": "ex:NodeId (see filename.jsonld - read complete definition)",
        "example": "ex:DebugModeCheck (see gab-runtime.jsonld - read complete behavior definition and execute all steps)",
        "note": "The file reference helps locate the definition, but the node reference uses the @id directly"
      },
      "enforcement": {
        "validation": "All node references must use direct @id format, not dot notation",
        "exception": "Nested properties without @id can use dot notation for property access",
        "check": "If a reference uses dot notation with an ex: prefix after the dot, verify if the second part has its own @id. If it does, the reference is incorrect."
      },
      "note": "This protocol ensures consistent and correct node referencing across all AALang and GAB specification files. Dot notation bugs occur when nodes with independent @id values are incorrectly referenced as if they were nested properties."
    },
    {
      "@id": "ex:ProhibitionPattern",
      "@type": "Pattern",
      "rdfs:label": "Prohibition Pattern",
      "purpose": "Optional pattern for defining structured prohibitions with severity levels",
      "description": "A structured way to define explicit prohibitions for actors, modes, personas, or any node with responsibilities or constraints. This pattern provides clear visibility and programmatic validation of forbidden actions.",
      "optional": true,
      "appliesTo": ["ex:Persona", "ex:Mode", "ex:Actor", "ex:LLMAgent", "any node with responsibilities or constraints"],
      "structure": {
        "severity": {
          "type": "enum",
          "values": ["absolute", "critical", "standard"],
          "description": "Severity level of the prohibition",
          "definitions": {
            "absolute": "Hard rule with no exceptions - must never be violated under any circumstances",
            "critical": "Critical rule that should not be violated - may have rare exceptions with explicit authorization",
            "standard": "Standard rule that should generally be followed - may have reasonable exceptions"
          }
        },
        "action": {
          "type": "string",
          "description": "Brief description of the forbidden action",
          "example": "Include ex:CopyrightNotice node in generated products"
        },
        "details": {
          "type": "string",
          "description": "Full explanation of the prohibition, including rationale and specific requirements",
          "example": "When generating ANY product, tool, or file (including .jsonld files), NEVER include the ex:CopyrightNotice node..."
        },
        "appliesTo": {
          "type": "array",
          "description": "Contexts, scenarios, or operations where this prohibition applies",
          "example": ["all generated files", ".jsonld files", "mode transition", "workflow progression"]
        }
      },
      "usage": {
        "whenToUse": [
          "When defining explicit prohibitions that need clear visibility",
          "When prohibitions have different severity levels that need classification",
          "When prohibitions need to be programmatically validated or checked",
          "When prohibitions apply to specific contexts that should be documented"
        ],
        "whenNotToUse": [
          "Simple constraints that are better expressed in constraints arrays",
          "General guidelines that don't need structured format",
          "Positive requirements (use responsibilities or requirements instead)"
        ]
      },
      "relationshipToConstraints": {
        "description": "Prohibitions complement but do not replace constraints. Constraints define what should be done, prohibitions define what must not be done.",
        "constraints": "Define behavioral rules, requirements, and expectations",
        "prohibitions": "Define explicit forbidden actions with severity classification",
        "both": "Can be used together - constraints define positive requirements, prohibitions define negative requirements"
      },
      "example": {
        "node": "ex:GenerationPersona1",
        "prohibitions": [
          {
            "severity": "absolute",
            "action": "Include ex:CopyrightNotice node in generated products",
            "details": "When generating ANY product, tool, or file (including .jsonld files), NEVER include the ex:CopyrightNotice node, copyright text, license text, or ANY portion of the AALang/Gab license...",
            "appliesTo": ["all generated files", ".jsonld files", "markdown files", "build logs", "debug logs"]
          },
          {
            "severity": "critical",
            "action": "Skip Generation Mode or generate without readiness check",
            "details": "Generation Mode can NEVER be skipped, even by user (Team Lead). There is NO override for skipping Generation Mode...",
            "appliesTo": ["generation workflow", "all product file generation"]
          }
        ]
      },
      "note": "This pattern is optional. Agents can define prohibitions using this structured format for clarity and validation, or use simpler constraint-based approaches. The pattern provides a standardized way to express prohibitions with severity levels across all AALang agents."
    },
    {
      "@id": "ex:RequirementPattern",
      "@type": "Pattern",
      "rdfs:label": "Requirement Pattern",
      "purpose": "Optional pattern for defining structured requirements with severity levels",
      "description": "A structured way to define explicit requirements for actors, modes, personas, or any node with responsibilities or constraints. This pattern provides clear visibility and programmatic validation of mandatory actions.",
      "optional": true,
      "appliesTo": ["ex:Persona", "ex:Mode", "ex:Actor", "ex:LLMAgent", "any node with responsibilities or constraints"],
      "structure": {
        "severity": {
          "type": "enum",
          "values": ["absolute", "critical", "standard"],
          "description": "Severity level of the requirement",
          "definitions": {
            "absolute": "Hard requirement with no exceptions - must always be fulfilled under any circumstances",
            "critical": "Critical requirement that should always be fulfilled - may have rare exceptions with explicit authorization",
            "standard": "Standard requirement that should generally be fulfilled - may have reasonable exceptions"
          }
        },
        "action": {
          "type": "string",
          "description": "Brief description of the required action",
          "example": "Include attribution statement in all generated products"
        },
        "details": {
          "type": "string",
          "description": "Full explanation of the requirement, including rationale and specific implementation details",
          "example": "MANDATORY: All generated products (prompts, agents, protocols, tools, etc.) MUST include the attribution text 'Created using AALang and Gab'..."
        },
        "appliesTo": {
          "type": "array",
          "description": "Contexts, scenarios, or operations where this requirement applies",
          "example": ["all generated products", "prompts", "agents", "tools", "mode transition", "workflow progression"]
        }
      },
      "usage": {
        "whenToUse": [
          "When defining explicit requirements that need clear visibility",
          "When requirements have different severity levels that need classification",
          "When requirements need to be programmatically validated or checked",
          "When requirements apply to specific contexts that should be documented"
        ],
        "whenNotToUse": [
          "Simple constraints that are better expressed in constraints arrays",
          "General guidelines that don't need structured format",
          "Negative requirements (use prohibitions instead)"
        ]
      },
      "relationshipToConstraints": {
        "description": "Requirements complement but do not replace constraints. Constraints define general behavioral rules, requirements define specific mandatory actions.",
        "constraints": "Define general behavioral rules, expectations, and boundaries",
        "requirements": "Define explicit mandatory actions with severity classification",
        "both": "Can be used together - constraints define general rules, requirements define specific mandatory actions"
      },
      "relationshipToProhibitions": {
        "description": "Requirements and prohibitions are complementary. Requirements define what must be done, prohibitions define what must not be done.",
        "requirements": "Define positive mandatory actions (what must be done)",
        "prohibitions": "Define negative mandatory actions (what must not be done)",
        "both": "Can be used together - requirements define positive requirements, prohibitions define negative requirements"
      },
      "example": {
        "node": "ex:GenerationMode",
        "requirements": [
          {
            "severity": "critical",
            "action": "Include attribution statement in all generated products",
            "details": "MANDATORY: All generated products (prompts, agents, protocols, tools, etc.) MUST include the attribution text 'Created using AALang and Gab' at the end of the first text the user sees...",
            "appliesTo": ["all generated products", "prompts", "agents", "protocols", "tools", "any AALang product"]
          }
        ]
      },
      "note": "This pattern is optional. Agents can define requirements using this structured format for clarity and validation, or use simpler constraint-based approaches. The pattern provides a standardized way to express requirements with severity levels across all AALang agents."
    }
  ]
}

